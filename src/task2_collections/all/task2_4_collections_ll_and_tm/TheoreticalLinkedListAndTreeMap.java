package task2_collections.all.task2_4_collections_ll_and_tm;



/**
 * 1.Какова производительность операций вставки и удаления элемента в LinkedList по сравнению
 * с ArrayList? Какие факторы влияют на производительность?
 *
 * 2.Как работает двусвязный список (Doubly Linked List)? Какие преимущества и недостатки
 * он имеет по сравнению с односвязным списком?
 *
 * 3.В каких сценариях TreeMap предпочтительнее использовать по сравнению с другими
 * реализациями Map (например, HashMap)?
 *
 * 4.Как обрабатываются дубликаты ключей в TreeMap? Можно ли хранить несколько значений для одного ключа?
 *
 * 5.Какие особенности делают TreeMap упорядоченной мапой? Каким образом элементы сортируются в TreeMap?
 */



import java.util.Map;
import java.util.TreeMap;

public class TheoreticalLinkedListAndTreeMap {
    public static void main(String[] args) {

    }

    /**
     * Как будет работать класс ниже , максимально подробно.
     */

    public class ListNode {
        String data;
        ListNode next;

        public ListNode(String data) {
            this.data = data;
        }
    }

    public void swapElements(ListNode head, int index1, int index2) {
        if (index1 == index2) {
            return;
        }

        ListNode prev1 = null;
        ListNode prev2 = null;
        ListNode current = head;
        int currentIndex = 0;

        while (current != null) {
            if (currentIndex == index1) {
                break;
            }

            prev1 = current;
            current = current.next;
            currentIndex++;
        }

        current = head;
        currentIndex = 0;

        while (current != null) {
            if (currentIndex == index2) {
                break;
            }

            prev2 = current;
            current = current.next;
            currentIndex++;
        }

        if (prev1 != null) {
            prev1.next = prev2.next;
        } else {
            head = prev2.next;
        }

        if (prev2 != null) {
            prev2.next = prev1.next;
        } else {
            head = prev1.next;
        }

        ListNode temp = prev1.next.next;
        prev1.next.next = prev2.next.next;
        prev2.next.next = temp;
    }






    /**
     *
     * Как будет работать код, расскажите максимально подробно.
     */

    public String findKeyWithMaxValue(TreeMap<String, Integer> treeMap) {
        if (treeMap == null || treeMap.isEmpty()) {
            return null;
        }

        Map.Entry<String, Integer> maxEntry = null;
        for (Map.Entry<String, Integer> entry : treeMap.entrySet()) {
            if (maxEntry == null || entry.getValue().compareTo(maxEntry.getValue()) > 0) {
                maxEntry = entry;
            }
        }

        return maxEntry.getKey();
    }
}













    /**
     * 1.Вставка: Вставка элемента в LinkedList обычно имеет временную сложность O(1), так как требуется просто
     * обновить ссылки. В ArrayList вставка в среднем имеет сложность O(n), так как может потребоваться перемещение
     * соседних элементов.
     *
     * Удаление: Удаление элемента из LinkedList также имеет временную сложность O(1), так как требуется только
     * обновить ссылки. В ArrayList удаление в среднем имеет сложность O(n), так как после удаления элементов нужно
     * сдвигать остальные элементы.
     *
     * Факторы, влияющие на производительность, включают размер коллекции и место вставки/удаления. Для ArrayList
     * вставка в начало и удаление из середины может быть более затратной операцией.
     *
     * 2.Doubly Linked List - это структура данных, в которой каждый элемент (узел) имеет две ссылки: одну на
     * предыдущий элемент и одну на следующий элемент. Это обеспечивает двунаправленную навигацию.
     *
     * Преимущества: Двусвязный список обеспечивает эффективную вставку и удаление элементов как в
     * начале, так и в конце. Он обеспечивает обратный доступ к элементам.
     *
     * Недостатки: Двусвязный список требует больше памяти для хранения дополнительных ссылок.
     * Он может потребовать больше времени для выполнения навигации по сравнению с односвязным списком.
     *
     * 3.TreeMap предпочтительно использовать, когда требуется упорядоченнколлая екция элементов по ключам.
     *
     * Когда нужно выполнять операции навигации, поиска ближайших значений (например, floor или ceiling) или диапазонных запросов.
     * Когда необходимо автоматически поддерживать упорядоченность элементов при вставке новых данных.
     * Когда ключи требуют уникальности (повторяющиеся ключи заменяют старые значения).
     *
     * 4.TreeMap не допускает дубликаты ключей. Если вы попытаетесь вставить элемент с уже существующим ключом,
     * новое значение заменит старое.
     * Нельзя хранить несколько значений для одного ключа. Для этой цели можно использовать Map<K, List<V>>,
     * где значение - это список элементов.
     *
     * 5.TreeMap - это реализация SortedMap, которая поддерживает упорядоченность элементов по ключам.
     * сортируются с использованием их ключей на основе их естественного порядка или собственного компаратора.
     *
     * По умолчанию элементы сортируются в естественном порядке ключей (например, для строк -
     * Если вы предоставляете собственный компаратор, он будет использоваться для сортировки.
     *
     *
     *
     * Задачи.
     *
     * 1.Метод swapElements меняет местами элементы списка с индексами index1 и index2.
     *
     *
     * 2.Метод findKeyWithMaxValue находит ключ с максимальным значением (лексикографически) в данном TreeMap.
     */
