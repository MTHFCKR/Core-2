package task2_collections.all.task2_1_collections_hm;

import java.util.HashMap;

/**
 * 1.Какие методы можно использовать для определения наличия ключа в HashMap, не вызывая исключений?
 *
 * 2.Что будет если в бакете больше 8 объектов?
 *
 * 3.Что такое "сериализация" в контексте HashMap, и как это может повлиять на производительность и безопасность данных?
 */

public class TheoreticalHashMap {
    public static void main(String[] args) {

        /**
         * Что выведет код?
         */

        HashMap<String, Integer> map = new HashMap<>();
        map.put("Apple", 3);
        map.put("Banana", 2);
        map.put("Cherry", 5);
        map.put("Banana", 4);
        System.out.println(map.get("Banana"));



        /**
         * Что выведет код?
         */

        HashMap<String, Integer> map1 = new HashMap<>();
        map1.put("Apple", 3);
        map1.put("Banana", 2);
        map1.put("Cherry", 5);
        System.out.println(map1.remove("Banana", 3));
        System.out.println(map1.remove("Banana", 2));





    }
































    /**
     * Ответы:
     *
     * 1.Для определения наличия ключа в HashMap без вызова исключений, можно использовать следующие методы:
     * containsKey(Object key): Метод containsKey(key) позволяет проверить, содержится ли указанный ключ в HashMap.
     * Если ключ существует, метод возвращает true, иначе false
     *
     * get(Object key): Метод get(key) позволяет получить значение, связанное с указанным ключом,
     * или null, если ключ не найден. На основе возвращенного значения можно определить, существует ли ключ
     *
     * Java 8 и выше: метод computeIfAbsent(Object key, Function<? super K,? extends V> mappingFunction):
     * Этот метод позволяет выполнить действие, только если ключ отсутствует в HashMap. Метод mappingFunction
     * выполняется для указанного ключа и добавляет значение, если ключ не существует.
     *
     * 2.Больше восьми элементов в одном бакете:
     * Если в один бакет попадает более восьми элементов, то внутренняя структура данных в HashMap переключается
     * на использование красно-черного дерева (Red-Black Tree), что позволяет обеспечивать эффективные операции на
     * больших количествах элементов в бакете. Это сделано для предотвращения линейного времени выполнения операций
     * в случае большого числа коллизий.
     *
     * Красно-черное дерево имеет логарифмическую сложность операций, что гарантирует хорошую производительность,
     * даже если в один бакет попадает большое количество элементов.
     *
     * 3.Сериализация в контексте HashMap - это процесс преобразования объекта HashMap в последовательность байтов,
     * которую можно сохранить в файле, передать по сети или использовать для сохранения состояния объекта в
     * постоянной памяти. После сериализации HashMap можно восстановить, воспользовавшись процессом десериализации,
     * который преобразует последовательность байтов обратно в объект HashMap.
     *
     * Сериализация может повлиять на производительность и безопасность данных следующим образом:
     * Производительность: Процесс сериализации и десериализации может быть затратным по времени и ресурсам.
     * В больших HashMap с большим количеством элементов сериализация может занять значительное время и требовать
     * дополнительной памяти для временного хранения сериализованных данных. Это может быть проблемой при работе с
     * крупными данными.
     *
     *
     *
     * Задачи
     *
     * 1:Код выведет "4", так как мы сначала добавили пару ключ-значение "Banana"-"2" в хэш-карту,
     * а затем перезаписали значение для ключа "Banana" на "4" с помощью второго put.
     *
     *
     * 2: false
     *    true
     *
     * Первый вызов remove("Banana", 3) вернет false, так как значение для ключа "Banana" не совпадает с указанным
     * значением (3). Второй вызов remove("Banana", 2) вернет true, так как значение для ключа "Banana" совпадает
     * с указанным значением (2), и элемент будет удален из хэш-карты.
     */


}
