package task2_2_collections_l_and_hl;

import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;

/**
 * 1. Что такое "кэширование прозрачной длины" (transparent length caching) в LinkedList, и как оно
 * влияет на производительность?
 *
 * 2.Что такое "кольцевой" (circular) LinkedList, и в каких ситуациях он может быть полезен?
 *
 * 3.Как проверить, пуст ли List, без использования isEmpty()?
 */
public class TheoreticalListAndLinkedHashMap {
    public static void main(String[] args) {


        /**
         * Что выведет код?
         */
        List<String> list = new LinkedList<>();
            list.add("A");
            list.add("B");
            list.add("C");
            list.add("D");
        System.out.println(list.get(2));


        /**
         * Что выведет код?
         */
        LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
        map.put("One", 1);
        map.put("Two", 2);
        map.put("Three", 3);
        map.put("Four", 4);
        System.out.println(map.keySet());





    }







    /**
     * Ответ :
     *
     * 1.Кэширование прозрачной длины" (transparent length caching) - это оптимизация, которая иногда используется
     * в реализациях связанных списков, включая LinkedList, чтобы ускорить операции получения длины списка.
     * Это делается путем хранения внутренней переменной, которая отслеживает текущую длину списка, и обновления этой
     * переменной при добавлении или удалении элементов.
     *
     * Идея заключается в том, чтобы избегать пересчета длины списка каждый раз, когда он запрашивается.
     * Вместо этого, когда элементы добавляются или удаляются, переменная, содержащая длину списка, обновляется
     * соответственно. Это может значительно ускорить операции получения длины списка, особенно в случае больших списков,
     * где пересчет может потребовать значительного времени.
     *
     * Прозрачность означает, что пользователь не должен беспокоиться о том, что длина списка кэшируется внутри
     * структуры данных. Он просто вызывает метод получения длины (например, size()), и реализация самостоятельно
     * управляет кэшированием.
     *
     * Однако стоит отметить, что при использовании "кэширования прозрачной длины" необходимо убедиться
     * в правильной синхронизации, если список используется в многопоточной среде. Изменение длины и обновление
     * кэша должны быть атомарными операциями, чтобы избежать гонок данных и непредсказуемого поведения.
     *
     * Как и всякие оптимизации, "кэширование прозрачной длины" может оказать положительное влияние на
     * производительность, но также требует дополнительного кода и управления, чтобы гарантировать правильное
     * функционирование во всех условиях.
     *
     *
     * 2.Кольцевой буфер (Ring Buffer): Кольцевые списки широко используются для реализации кольцевых буферов.
     * Это позволяет сохранять последовательность данных, перезаписывая старые данные, когда буфер полностью заполнен.
     * Кольцевые буферы эффективно используют память и могут использоваться, например, для записи данных с сенсоров или
     * для буферизации потоковой информации.
     *
     Циклические итерации: Когда вам нужно обрабатывать данные в цикле до достижения определенного условия,
     кольцевые списки могут быть полезными. Например, если у вас есть список задач, и вы хотите, чтобы после
     обработки последней задачи вы вернулись к началу списка и продолжили обработку с начала.

     Круговая очередь (Circular Queue): Кольцевые списки могут использоваться для реализации круговых очередей, где элементы добавляются и удаляются в кольцевом порядке. Это может быть полезно, например, при управлении задачами в пуле задач.
     Решение задач графовой теории: В некоторых алгоритмах графовой теории, таких как поиск циклов в графах, кольцевые списки могут быть полезными для представления и обработки данных.
     Эффективное перемещение: В некоторых сценариях перемещение между элементами списка может быть эффективнее, чем в обычном связанном списке, так как нет необходимости перескакивать на начало списка после достижения конца

     *
     *
     * 3.Вы можете проверить, пуст ли List, с помощью list.size() == 0.
     * Однако, isEmpty() является более предпочтительным и читаемым способом для этой цели.
     *
     * Задачи :
     *
     * 1.Код выведет "C", так как list.get(2) возвращает элемент, находящийся по индексу 2 (нумерация начинается с 0),
     * который в данном случае равен "C".
     *
     * 2.[One, Two, Three, Four]
     */
}
